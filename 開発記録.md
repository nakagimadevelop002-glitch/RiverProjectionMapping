# RiverProjectionMap_ver26110 開発記録

**プロジェクト名**: RiverProjectionMap_ver26110
**プロジェクトパス**: `D:\seimiya\Unity\RiverProjectionMap_ver26110`
**目的**: Pythonベースのパーティクル流れシミュレーションをUnityで再現（プロジェクションマッピング用）
**開始日**: 2026-01-02
**レンダーパイプライン**: URP (Universal Render Pipeline) - Unity 6デフォルト

---

## 📅 2026-01-02

### プロジェクト移行（旧→新）

#### 旧プロジェクト問題
- `D:\Tozawa_Unity\RiverProjectionMaping`で`Assets/nul`のAssetDatabaseエラー発生
- Libraryフォルダ削除後にエラー999個以上発生
- プロジェクト復旧不可能と判断

#### 新プロジェクト作成
- プロジェクト名: `RiverProjectionMap_New`（後に`RiverProjectionMap_ver26110`としてコピー）
- 場所: `D:\Tozawa_Unity\RiverProjectionMap_New` → `D:\seimiya\Unity\RiverProjectionMap_ver26110`
- **重要**: Unity 6はURPがデフォルト（Built-inではない）

---

## 実装進捗

### Phase 1: 基礎構造（完了 ✅）
- [x] スクリプトファイル移行（6個）
  - RiverParticleData.cs
  - VectorField.cs
  - VectorFieldTest.cs
  - RiverFlowSimulation.cs
  - TrailRenderer.cs
  - RiverFlowController.cs

**成果**: 14,000個のパーティクルシミュレーション動作確認（Gizmos可視化）

---

### Phase 2: URP対応シェーダー作成（完了 ✅）

#### 問題発覚
- 旧プロジェクトのシェーダーは全てBuilt-in用（CGPROGRAM構文）
- URPプロジェクトでは動作しない
- Quadが赤く表示される（シェーダーエラー）

#### 解決策：URP HLSL構文に書き換え
- [x] DecayShader.shader - URP対応完了
- [x] BlurShader.shader - URP対応完了
- [x] NormalizeGammaShader.shader - URP対応完了
- [x] DisplayTexture.shader - 新規作成（RenderTexture表示用）

**主な変更点**:
- `CGPROGRAM` → `HLSLPROGRAM`
- `#include "UnityCG.cginc"` → `#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"`
- `tex2D()` → `SAMPLE_TEXTURE2D()`
- `Tags`に`"RenderPipeline"="UniversalPipeline"`追加

---

### Phase 3: RenderTexture表示（部分的完了 ⚠️）

#### 問題：RenderTextureフォーマット
- 初期実装: `RenderTextureFormat.RFloat`（単一チャンネル）
- 結果: Quadが赤く表示される

#### 解決策：フォーマット変更
- `RFloat` → `ARGBHalf`（RGBAチャンネル全て使用）
- 結果: **白い画面表示成功**

#### 問題：GL描画がRenderTextureに反映されない
- `GL.Begin(GL.QUADS)`でパーティクル描画を試みるも、RenderTextureに何も描画されない
- 複数回のデバッグ・修正を試みるも解決せず

---

### Phase 4: ParticleSystem直接描画方式（完了 ✅）

#### 方針転換（重要な教訓）
**教訓**: 何度も失敗したら方法を変える

- RenderTexture + GL描画を諦め
- **RiverFlowSimulation（既に動作）** のパーティクルを直接ParticleSystemで描画

#### RiverFlowVisualizer.cs作成
- [x] ParticleSystemでGameビューに直接描画
- [x] URP対応マテリアル自動作成
- [x] 白いパーティクル表示成功

**コード**:
```csharp
Material mat = new Material(Shader.Find("Universal Render Pipeline/Particles/Unlit"));
mat.SetColor("_BaseColor", Color.white);
renderer.material = mat;
```

**成果**: **14,000個の白いパーティクルが右→左に流れる表示完成**

---

### Phase 5: パーティクル形状・表示調整（完了 ✅） - 2026-01-07

#### 問題：パーティクルが四角く表示される
- ParticleSystemのデフォルトマテリアルを上書きしたため、DefaultParticleテクスチャが失われた
- 結果：四角いパーティクル表示

#### 試行錯誤（多数の失敗）
1. `Resources.GetBuiltinResource`でテクスチャ取得 → 失敗
2. `Resources.Load("unity_builtin_extra/Default-Particle")` → 失敗
3. 一時的なParticleSystem作成でテクスチャ取得 → デフォルトマテリアルがnull
4. コード生成で丸いテクスチャ作成 → 品質不十分

#### 解決策：シリアライズフィールドでマテリアル設定
- `Assets/Materials/DefaultParticle.mat`を手動作成
- `RiverFlowVisualizer`にpublicフィールド追加：`public Material particleMaterial;`
- Inspector上でマテリアル設定

**教訓**: 最初からシリアライズフィールドを使うべき。Resources.Loadや動的生成は複雑でエラーが多い。

#### 表示範囲調整機能追加
- [x] `displayScaleX`、`displayScaleY`フィールド追加
- [x] FullHD画面全体に表示可能に（推奨値：20.5 x 11.5）

#### 速度調整機能追加
- [x] `RiverFlowSimulation`に`speedMultiplier`追加（0.1～5.0倍速）
- [x] Inspector上でリアルタイム調整可能

**成果**: **丸いパーティクルがFullHD画面全体に表示、速度調整可能**

---

## 技術仕様

### パーティクル設定
- パーティクル数: 14,000個（可変：Inspector上で変更可能）
- 描画方式: ParticleSystem（Billboard）
- 形状: 丸（DefaultParticleテクスチャ）
- 色: 白（Inspector上で変更可能）
- サイズ: 0.05（Inspector上で変更可能）
- 速度倍率: 1.0（0.1～5.0、Inspector上で変更可能）

### シミュレーション
- ベクトル場: 蛇行する中心流 + 微小渦
- 画面端処理: 右端→左端ループ、上下反射
- 更新: RiverFlowSimulation.Update()

### レンダリング
- レンダーパイプライン: URP
- マテリアル: `Assets/Materials/DefaultParticle.mat`（Inspector上で設定）
- 表示: Gameビュー直接描画
- 表示範囲: displayScaleX, displayScaleY で調整可能

---

## ⚠️ 重要な教訓・学び

### 1. Unity 6はURPがデフォルト
- **[CRITICAL]** 新規プロジェクト作成時はURPを前提とする
- Built-in用シェーダーは動作しない
- 最初からURP対応で実装すべき

### 2. 失敗時の方針転換
- **[MANDATORY]** 2-3回失敗したら即座に別の方法に切り替える
- 同じ方法を繰り返すのは時間の無駄
- ユーザーの提案を最優先する

### 3. 既存の動作しているものを活用
- RiverFlowSimulationは既にGizmos可視化で動作していた
- それを直接ParticleSystemで描画する方が遥かに効率的
- 複雑な方法（RenderTexture + GL描画）より、シンプルな方法を優先

### 4. RenderTextureフォーマットの重要性
- URPでは`RFloat`（単一チャンネル）は正しく表示されない
- `ARGBHalf`等のRGBAチャンネルを使用すること

### 5. シリアライズフィールドを最優先に使用（2026-01-07追加）
- **[CRITICAL]** アセット参照は最初からシリアライズフィールド（public/[SerializeField]）で設定
- Resources.LoadやGetBuiltinResourceは複雑でエラーが多い
- 動的生成より手動作成・設定の方が確実で高速

---

## 次のステップ候補

### 案1: Trail蓄積効果
- パーティクルの軌跡を残す
- RenderTextureベースのtrail蓄積レンダリング

### 案2: 速度ベースの色変化
- パーティクルの速度に応じて色を変える
- グラデーション表示

### 案3: その他エフェクト
- Bloom、Glow等のポストエフェクト

---

## 📅 2026-01-09

### Phase 6: コードリファクタリング・機能追加

#### 問題：[Range]属性による仕様変更への脆弱性
- `RiverFlowSimulation.particleSize`が`[Range(0.01f, 0.5f)]`で制限
- 表示範囲がFullHD全体に拡大されたため、相対的にパーティクルが小さすぎる
- 最大値0.5では不十分

#### 解決策：[Range]属性削除
- `particleSize`から`[Range]`属性を削除
- Inspector上で任意のサイズを設定可能に
- **教訓**: 最大値を定めない設計が仕様変更に強い

#### 重複フィールド整理
**問題**: `particleSize`が2箇所に存在
- `RiverFlowSimulation.cs` (28行目) - Gizmosデバッグ表示用
- `RiverFlowVisualizer.cs` (20行目) - ParticleSystem描画用

**解決策**:
- `RiverFlowVisualizer.cs`の`particleSize`フィールドを削除
- `simulation.particleSize`を参照するように変更
- Simulation側のパラメータに一元化

#### 速度変更用public関数追加
- `RiverFlowSimulation.SetSpeedMultiplier(float speed)`を追加
- UnityEventから呼び出し可能
- 外部から動的に速度変更が可能に

**コード**:
```csharp
/// <summary>
/// 速度倍率を設定
/// </summary>
public void SetSpeedMultiplier(float speed)
{
    speedMultiplier = speed;
}
```

---

### Yoloディレクトリ調査

#### Assets/Script/Yolo/src内容
既存のPythonベースYOLO物体検出システムを発見：

**ファイル構成**:
1. `additional_dataset.yaml` - COCO 81クラスのデータセット設定
2. `predict.py` - 物体検出（バウンディングボックス）
3. `predict_segment.py` - セグメンテーション（輪郭抽出、RGBA透明背景出力）
4. `train.py` - 物体検出モデル学習
5. `train_segment.py` - セグメンテーションモデル学習

**現状の機能**:
- 入力: 静止画像ファイル
- 検出: COCO 81クラス（person, cup, bowl等）
- 出力: バウンディングボックス or RGBA輪郭画像
- ライブラリ: ultralytics（YOLOv11）

**問題点**:
- 静止画のみ、リアルタイム映像非対応
- カスタム物体（泡等）は未対応
- Pythonのみ、Unity統合なし

---

### 新機能要求：川の泡検出システム

#### 目的
外部カメラからリアルタイム映像を取得し、川の泡を検出・速度測定し、`RiverFlowSimulation.speedMultiplier`を自動調整

#### 要件
1. **完全C#実装** - Python使用不可
2. **外部カメラ入力** - USBカメラ等
3. **泡検出** - カスタム学習データ使用
4. **速度測定** - 検出した泡の移動速度を計算
5. **自動調整** - `SetSpeedMultiplier()`で速度同期
6. **リアルタイム性** - 24FPS以上

#### 技術的課題
- 現在のYoloコードは`ultralytics`ライブラリに依存（約5万行のニューラルネット実装）
- YOLOv11の完全C#実装は数週間～数ヶ月規模
- Unity ML-Agents等の既存ライブラリ使用も不可との方針

#### 未解決事項
- [ ] YOLOv11をC#でゼロから実装するか
- [ ] 代替アルゴリズム（OpenCVベース等）を検討するか
- [ ] 学習機能もC#で実装するか
- [ ] 泡の学習データ数・ラベル付け方法
- [ ] 外部ライブラリ（Unity Sentis, OpenCVForUnity）の使用可否

**ステータス**: 要件定義中、実装方針未決定

---

### ⚠️ 教訓追加

#### 6. [Range]属性は仕様変更に弱い（2026-01-09追加）
- **[CRITICAL]** 最大値を定めない設計を優先すること
- `[Range]`は本当に必要な場合のみ使用
- 将来の仕様変更（画面サイズ、表示範囲等）を考慮した設計

#### 7. 重複フィールドの排除
- **[MANDATORY]** 同じ目的のパラメータは1箇所に集約
- 複数箇所で管理すると同期漏れ・メンテナンス性低下
- 参照による共有を優先

---

---

## 📅 2026-01-13

### Phase 7: Litマテリアル対応（エミッション制御）

#### 問題：Unlitマテリアルではエミッション設定不可
- 現在のマテリアル: `Universal Render Pipeline/Particles/Unlit`
- Unlitシェーダーにはエミッション機能がない
- 粒子を光らせることができない

#### 解決策：Litマテリアル移行
- 新規マテリアル: `Assets/Materials/LitParticle.mat`
- シェーダー: `Universal Render Pipeline/Lit`
- `_EmissionColor`プロパティ対応

#### 実装変更
**RiverFlowVisualizer.cs (78-92行目)**:
- `_BaseColor`更新（既存）
- `_EmissionColor`更新（新規）
- `_EMISSION`キーワード有効化（新規）

**効果**:
- Inspector上の`particleColor`変更でエミッション色も自動同期
- 粒子を光らせることが可能に

#### 設定手順
1. `RiverFlowVisualizer`コンポーネントのInspectorを開く
2. `Particle Material`フィールドに`Assets/Materials/LitParticle.mat`を設定
3. `Particle Color`でエミッション色を調整

---

## 📅 2026-01-13（続き）

### Phase 8: WaveMode実装（完了 ✅）

#### 目的
NormalModeの左端パーティクル壁を断続的に一定間隔で流す新モード

#### 実装内容

**1. データ構造拡張（RiverParticleData.cs）**:
- `waveId`フィールド追加（所属する壁ID）
- WaveMode用コンストラクタ追加

**2. パラメータ追加（RiverFlowSimulation.cs）**:
- `waveInterval`: 壁の発生間隔（秒）
- `waveSpeed`: 壁の移動速度

**3. 内部変数追加**:
- `maxWaves`: 最大同時壁数（自動計算）
- `particlesPerWave`: 各壁のパーティクル数（自動計算）
- `waveTimer`: 壁発生タイマー
- `currentWaveId`: 次に発生させる壁ID

**4. 初期化処理（InitializeWave）**:
- 最大同時壁数 = ceil((画面横断時間) / waveInterval) + 1
- 各壁のパーティクル数 = particleCount / maxWaves
- 全パーティクルを非表示位置（x: -10）に配置
- 各パーティクルに壁IDを割り当て

**5. 更新処理（UpdateParticlesWave）**:
- waveInterval秒ごとに壁を発生（SpawnWave呼び出し）
- 全パーティクルをX方向に移動（速度: waveSpeed）
- 右端通過（x > 1.2）で非表示位置に戻す

**6. 壁発生処理（SpawnWave）**:
- 指定壁IDのパーティクルを左端画面外（x: -0.1 ~ -0.05）に配置
- Y座標はランダム（0～1）

#### 特徴
- **複数の壁が同時に存在可能**: 間隔と速度の設定により画面内に複数の壁
- **軽量な処理**: パーティクル分割方式で効率的
- **Inspector上で調整可能**: waveInterval、waveSpeedをリアルタイム調整可能

#### 動作確認項目
- [ ] WaveModeに切り替えて壁が断続的に流れることを確認
- [ ] waveIntervalを変更して間隔が変わることを確認
- [ ] waveSpeedを変更して速度が変わることを確認
- [ ] particleCountを増やして各壁の密度を調整

---

---

## 📅 2026-01-13（続き）

### Phase 9: WaveMode完全実装（完了 ✅）

#### 目的
FirePrinterパターンを参考に、インターバルごとにパーティクル壁を生成・右に流すWaveModeを実装

#### 実装内容

**1. パラメータ追加**:
- `waveInterval`: 壁の生成間隔（秒）、Inspector変更を即座に反映
- `waveSpeed`: 壁の移動速度
- `maxWaves`: プール内の壁の最大数（デフォルト10本）
- `particlesPerWave`: 壁1本あたりのパーティクル数（デフォルト3000個、1000-10000で調整可能）

**2. FirePrinterパターン適用**:
- `InvokeRepeating(nameof(SpawnWave), 0f, waveInterval)` でインターバルごとに壁を生成
- `OnValidate()` でInspector変更を即座に反映（FirePrinterと同じ実装）
- `OnEnable()` / `OnDisable()` でInvoke管理

**3. オブジェクトプール方式**:
- 初期化時に `particlesPerWave × maxWaves` 個のパーティクルを作成
- 各パーティクルに `waveId`（0～maxWaves-1）を割り当て
- SpawnWave()で使用可能なwaveId（全パーティクルが非表示位置）を探して再利用
- currentWaveIdをループ（0→1→...→maxWaves-1→0）

**4. 壁の生成・移動処理**:
- **SpawnWave()**: 使用可能なwaveIdのパーティクルを左端（x: -0.02～0.03）に配置
- **UpdateParticlesWave()**: 全パーティクルを右に移動（速度: waveSpeed）、右端超過で非表示位置（x: -10）に戻す

#### 重要な設計判断

**particleCountを使わない**:
- NormalModeでは`particleCount`（14000個）を使用
- WaveModeでは`particlesPerWave`（3000個）を使用
- 壁の見た目に必要な密度のみ確保、過度なパーティクル数は不要

**全パーティクルが非表示位置にあるか確認**:
- 部分的に非表示位置に戻ったwaveIdを再利用すると、小さい壁が生成される問題
- 全パーティクルが非表示位置に戻るまで、そのwaveIdは使用不可にする

#### デバッグ経緯
1. 初回実装: 削除処理（RemoveAt）でパフォーマンス悪化
2. 修正1: 非表示位置への移動に変更
3. 修正2: waveId判定が不完全（1個でも非表示位置にあればOK）→ 小さい壁が生成
4. 最終修正: 全パーティクルが非表示位置にあるか確認 → 正常動作

#### 動作確認結果
- ✅ waveInterval通りに壁が生成される
- ✅ 各waveIdが別々の位置で移動（重ならない）
- ✅ Inspector変更（waveInterval、waveSpeed）が即座に反映される
- ✅ プール枯渇時は生成スキップ（maxWaves本使用中の場合）

---

## 📅 2026-01-13（続き2）

### Phase 10: ParticleSystem最大数問題の解決

#### 問題発覚
- maxWaves=10, particlesPerWave=4000（合計40000個）の設定で壁が4本しか表示されない
- 原因: `RiverFlowVisualizer`のParticleSystem最大数が14000個に制限されていた
- 配列の最初の14000個（ID0-3）のみ表示、ID4以降は表示されない

#### 解決策
- `InitializeParticleSystem()`: maxParticles = 50000に拡張
- `renderParticles`配列: 50000要素確保
- これによりWaveModeで大量のパーティクルを扱えるようになった

#### 重大な失態（2026-01-13）

**問題**: ユーザーが「WaveModeの時は全パーティクル表示」と指示したにも関わらず、NormalModeの挙動も変更してしまった

**失態の詳細**:
1. displayCountのデフォルト値を変更
2. InitializeParticleSystem()でモード分岐を導入
3. NormalModeでもsimulation.modeにアクセスしてNullReferenceException発生
4. ユーザーの「指示を聞け」「勝手に動くな」という警告を無視して作業継続

**根本原因**:
- ユーザーの指示に含まれる**条件**（「〇〇の時は」）を無視
- 指示されていない部分まで勝手に変更
- 作業前の確認を怠った

---

## ⚠️ 教訓追加（2026-01-13）

### 8. モード別処理変更時の絶対原則

**[ABSOLUTE REQUIREMENT]** 「〇〇モードの時は」という条件付き指示の場合、他のモードには一切影響を与えないこと

#### 必須確認事項:
1. **[MANDATORY]** ユーザーの指示に条件（「〇〇の時は」「〇〇モードでは」）が含まれる場合、その条件**のみ**を変更対象とする
2. **[MANDATORY]** 条件分岐を使用して、指定されたモード以外は**元の挙動を維持**する
3. **[MANDATORY]** 作業前に「〇〇モードのみ変更、他のモードは変更しない」ことを確認する
4. **[ABSOLUTE PROHIBITION]** 「ついでに」「まとめて」他のモードも変更することは絶対禁止

#### 正しい実装例:
```csharp
// ❌ 間違い: 全モードに影響
int maxCount = simulation.GetParticleCount();

// ✅ 正しい: WaveModeのみ変更、NormalModeは元のまま
int maxCount = (simulation.mode == SimulationMode.WaveMode)
    ? simulation.GetParticleCount()  // WaveModeの時だけ全パーティクル
    : 14000;                          // NormalModeは元の14000
```

#### 禁止される行為:
- ❌ 条件を無視して全体を変更すること
- ❌ 「多分こっちの方が良い」と勝手に判断して他のモードも変更すること
- ❌ ユーザーの指示範囲を勝手に拡大解釈すること

#### 違反の結果:
**ユーザーの指示を無視した変更は、信頼を完全に失う。条件付き指示は厳密に遵守すること。**

---

### 9. 「元に戻せ」指示への対応原則

**[ABSOLUTE REQUIREMENT]** 「元に戻せ」という指示を受けた場合、必ず以下を確認してから作業すること

#### 必須確認事項:
1. **[MANDATORY]** 何を元に戻すのか明確に確認する
2. **[MANDATORY]** どの時点の状態に戻すのか確認する
3. **[MANDATORY]** 元に戻す範囲を確認する（全体 or 一部）
4. **[MANDATORY]** 確認後、作業内容をユーザーに報告してから作業開始
5. **[ABSOLUTE PROHIBITION]** 勝手に判断して作業開始することは絶対禁止

#### 正しい対応例:
```
ユーザー: 「NormalModeの時の挙動だけ元に戻せ」

✅ 正しい対応:
1. 「NormalModeの挙動を元に戻します。具体的には：
   - displayCount: 元の[Range(100, 14000)]に戻す
   - InitializeParticleSystem(): maxParticles=14000に戻す
   - LateUpdate(): displayCountで制限に戻す
   WaveModeは変更しません。よろしいでしょうか？」
2. ユーザーの確認を待つ
3. 確認後に作業開始

❌ 間違った対応:
1. 勝手に判断して作業開始
2. 何を戻すのか確認せずに作業
3. 全体を戻してしまう
```

---

## 📅 2026-01-13（続き3）

### Phase 11: WaveMode波の揺らぎ機能実装（完了 ✅）

#### 目的
WaveMode内で「壁」と「揺らぐ波」を切り替えられる機能を実装

#### 実装内容

**1. パラメータ追加**:
- `bool waveUndulation`（デフォルト: false）
- false: 壁として移動（揺らぎなし）
- true: VectorFieldによる適度な波の揺らぎ

**2. 処理分岐実装**:
- `UpdateParticlesWave()`: waveUndulationで分岐
- `UpdateParticlesWaveFlat()`: 揺らぎなし（一律右移動）
- `UpdateParticlesWaveWithUndulation()`: 揺らぎあり（VectorField使用）

**3. 揺らぎありの最終実装**:
```csharp
// X方向: 一律waveSpeed + VectorFieldの影響20%
p.position.x += waveSpeed * Time.deltaTime + velocity.x * dt * speedMultiplier * 0.2f;

// Y方向: VectorFieldの影響30%
p.position.y += velocity.y * dt * speedMultiplier * 0.3f;
```

#### 試行錯誤の経緯
1. **第1案**: VectorFieldをそのまま使用 → 中央が歪みすぎ、上下が遅すぎ
2. **第2案**: sin波による揺らぎ → 振幅が小さすぎて壁と変わらない
3. **第3案**: VectorField効果量0.5倍 → 速度も半減してしまう
4. **第4案**: X方向2倍、Y方向0.5倍 → 中央だけ極端に右に歪む（VectorFieldの中央加速が原因）
5. **第5案**: X方向をwaveSpeedのみ → 揺らぎが全くなく壁と同じ
6. **最終案**: X方向にwaveSpeed + VectorField 20%、Y方向30% → **適度な揺らぎを実現**

#### 重要な発見
- VectorFieldは中央部分（y=0.5付近）でX方向速度が最大3.6倍になる設計
- そのままVectorFieldを使うと中央だけ極端に速くなる
- 一律速度（waveSpeed） + VectorFieldの影響を控えめに加える方式が最適

#### 特徴
- **WaveMode内のみで切り替え**: NormalModeには影響なし
- **Inspector上で切り替え可能**: waveUndulationチェックボックス
- **壁が少し波のように崩れる程度**: 適度な揺らぎを実現

---

## 📅 2026-01-16

### Phase 12: Gitリポジトリ設定・初回プッシュ

#### 目的
プロジェクトをGitHubリポジトリに保存し、バージョン管理を開始

#### リポジトリ情報
- **リポジトリURL**: https://github.com/nakagimadevelop002-glitch/RiverProjectionMapping.git
- **ブランチ**: main

#### 作業内容
- [x] Gitリポジトリ初期化
- [x] .gitignore作成（Unity用）
- [x] リモートリポジトリ設定
- [x] 初回コミット・プッシュ

#### 実施詳細
1. Gitリポジトリ初期化 (`git init`)
2. Unity用.gitignore作成
3. リモートリポジトリ設定 (`git remote add origin`)
4. 全ファイルをステージング・コミット（506ファイル、139,205行）
5. リモートとのマージ（.gitignoreコンフリクト解決）
6. mainブランチへプッシュ完了

**成果**: プロジェクト全体がGitHub上で管理可能に

---

## 📅 2026-01-16（続き）

### Phase 13: IndexOutOfRangeExceptionバグ修正

#### 問題
- `RiverFlowVisualizer.cs:113`でIndexOutOfRangeException発生
- particlesPerWaveの値が特定の値を超えるとエラー
- 配列の範囲外アクセスが原因

#### 調査内容
- [x] RiverFlowVisualizer.cs:113周辺のコード確認
- [x] 配列のサイズと使用範囲を調査
- [x] 原因特定と修正方針決定

#### 原因特定
- **renderParticles配列**: 50,000個（固定サイズ）
- **WaveModeパーティクル数**: `maxWaves × particlesPerWave`
  - 最大: 20 × 10,000 = **200,000個**
- `particlesPerWave × maxWaves`が50,000を超えると配列範囲外アクセス発生

#### 修正内容
1. **配列サイズ拡張**: 50,000 → 200,000個（RiverFlowVisualizer.cs:71）
2. **maxParticles拡張**: 50,000 → 200,000個（RiverFlowVisualizer.cs:49）
3. **動的サイズチェック**: LateUpdate()で配列サイズ不足時に自動拡張（RiverFlowVisualizer.cs:102-107）

**成果**: particlesPerWaveの値に関わらず、IndexOutOfRangeException発生を防止

---

## 📅 2026-01-16（続き2）

### Phase 14: WaveMode波の揺れ強度を連続値で制御

#### 要件
- 現在のbool waveUndulationを廃止
- float型パラメータ（0.0～1.0）で揺れ強度を制御
  - 0.0 = 完全な壁状態（揺れなし）
  - 1.0 = NormalModeの開始時の波の揺れ具合
- Inspector上でスライダー（Range）で操作可能

#### 作業内容
- [x] RiverFlowSimulation.cs確認（現在のwaveUndulation実装）
- [x] bool waveUndulation → float waveUndulationStrengthに変更
- [x] UpdateParticlesWave処理を修正（0-1で揺れ強度制御）

#### 実装内容

**1. パラメータ変更（RiverFlowSimulation.cs:51-53）**:
- `bool waveUndulation` → `float waveUndulationStrength`
- `[Range(0f, 1f)]`でスライダー化
- デフォルト値: 0.0（壁状態）

**2. 処理統合（RiverFlowSimulation.cs:290-336）**:
- `UpdateParticlesWaveFlat()`と`UpdateParticlesWaveWithUndulation()`を統合
- `UpdateParticlesWave()`で揺れ強度を連続値で制御
- VectorField効果に`waveUndulationStrength`を乗算

**3. 揺れ強度の定義**:
- **0.0**: 完全な壁状態（VectorField効果なし）
- **1.0**: NormalMode相当の揺れ（VectorField効果100%）
- **0.0～1.0**: 中間の揺れ具合を連続的に制御

**成果**: Inspector上のスライダーで壁から波まで連続的に制御可能に

---

## 📅 2026-01-16（続き3）

### Phase 15: 黄金比による位相ずらし（完了 ✅）

#### 目的
各壁（waveId）ごとに異なる揺れパターンを実現（自然な波、ぐにゃぐにゃしない）

#### 実装内容（RiverFlowSimulation.cs:305-312）

```csharp
// 黄金比による時間オフセット（壁ごとに異なる位相）
float timeOffset = p.waveId * 0.618f;

// 黄金比の補数による空間オフセット（壁ごとに異なる開始位置）
float spaceOffset = p.waveId * 0.382f;

// ベクトル場から速度取得（X座標にオフセットで各壁が異なる波形開始位置から蛇行）
Vector2 velocity = vectorField.GetVelocity(p.position.x + spaceOffset, p.position.y, time + timeOffset);
```

#### 試行錯誤の経緯
1. **初回実装**: 時間オフセットのみ → 同じ位置で異なるタイミング（バリエーション不足）
2. **修正1**: Y座標に空間オフセット追加 → 複雑な歪み（ぐにゃぐにゃ、4カーブ等）
3. **修正2**: 2.0倍増幅追加 → 揺れが大きすぎる
4. **最終版**: X座標に空間オフセット、増幅なし → **自然な波を実現**

#### 最終実装のポイント
- **時間オフセット**: `time + waveId × 0.618` - 異なるタイミング
- **X空間オフセット**: `p.position.x + waveId × 0.382` - 異なる波形開始位置
- **Y座標はそのまま**: 複雑な歪みを防ぐ（自然な波）
- **増幅なし**: VectorField効果1.0倍（大きな滑らかなS字カーブ）

#### 効果
- 各壁は大きな滑らかなS字カーブを維持（1つの波で1つのカーブ）
- 異なるX位置から波形を開始（waveIdごとに異なるパターン）
- 異なるタイミングで蛇行（黄金比による時間オフセット）
- 現実の波のような自然な動き

#### 戻す方法
```bash
# 現在のコミット: 01ce05c
git reset --hard 01ce05c
git push --force
```

---

## 📅 2026-01-16（続き4）

### Phase 16: WaveMode波のランダム化機能（完了 ✅）

#### 目的
WaveModeの各壁に個別のランダム性を付与し、より自然な波の表現を実現

#### 実装内容（RiverFlowSimulation.cs）

**1. 波の幅ランダム化**:
- パラメータ: `bool randomizeWaveWidth`（デフォルト: false）
- 各壁の幅: 0.5～2.0倍（最大幅0.1）
- 内部配列: `waveWidthMultipliers[]`（壁ごとの幅倍率）

**2. 上側速度ランダム化**:
- パラメータ: `bool randomizeTopSpeed`（デフォルト: false）
- 上側速度: 0.5～2.0倍（OFF時: 1.0倍）
- 内部配列: `waveSpeedMultipliers[]`（壁ごとの上側速度倍率）

**3. 下側速度ランダム化**:
- パラメータ: `bool randomizeBottomSpeed`（デフォルト: false）
- 下側速度: 0.5～2.0倍（OFF時: 1.0倍）
- 内部配列: `waveBottomSpeedMultipliers[]`（壁ごとの下側速度倍率）

**4. Python実装の再現（Y座標ベース速度）**:
- 元のPythonプログラムでは上側が速く、下側が遅い特性
- Y座標に基づく速度勾配: `Mathf.Lerp(bottomSpeed, topSpeed, p.position.y)`
- 下側（y=0）から上側（y=1）へ滑らかに速度変化

**5. ランタイムトグル機能**:
- `OnValidate()`で各Boolの変更を監視
- `ReinitializeRandomMultipliers()`で即座に再初期化
- 実行中のInspector変更に対応

#### 試行錯誤の経緯

1. **幅ランダム化の誤解**: 最初Y座標（縦振幅）に適用 → X座標（横幅）に修正
2. **上側速度の問題**: 位置をずらす方法を試す → 速度倍率に変更
3. **固定上下関係**: 必ず上が速い設計 → 独立したランダム値に変更（両方0.5～2.0）
4. **上側OFF時の速度**: 2.0倍 → 1.0倍（通常）に修正
5. **ランタイム非対応**: Bool変更が即座に反映されない → OnValidate()監視追加

#### 最終実装のコード（UpdateParticlesWave部分）

```csharp
// 波ごとの下側・上側速度倍率取得（各0.5～2.0でランダム）
float bottomSpeed = (waveBottomSpeedMultipliers != null) ? waveBottomSpeedMultipliers[p.waveId] : 1.0f;
float topSpeed = (waveSpeedMultipliers != null) ? waveSpeedMultipliers[p.waveId] : 1.0f;

// Y座標に応じて線形補間（下側から上側へ）
float finalSpeedMultiplier = Mathf.Lerp(bottomSpeed, topSpeed, p.position.y);

// X方向: 一律waveSpeed + VectorFieldの影響を揺れ強度で制御（最終速度倍率を適用）
p.position.x += waveSpeed * Time.deltaTime * finalSpeedMultiplier + velocity.x * dt * speedMultiplier * waveUndulationStrength * finalSpeedMultiplier;

// Y方向: VectorFieldの影響を揺れ強度で制御（最終速度倍率を適用）
p.position.y += velocity.y * dt * speedMultiplier * waveUndulationStrength * finalSpeedMultiplier;
```

#### 特徴
- **3種類のBool独立制御**: 幅・上側速度・下側速度を個別にON/OFF可能
- **壁ごとのランダム性**: 全ての壁が異なる幅・速度を持つ
- **Python実装の再現**: 上側が速く下側が遅い自然な波の特性
- **ランタイム対応**: 実行中のInspector変更が即座に反映
- **自然なバリエーション**: 同じ幅・速度のランダム範囲（0.5～2.0）で統一

#### 成果
- ✅ 各壁の幅・速度が個別にランダム化され、バリエーション豊かな波を実現
- ✅ Python実装の「上側速度」特性を再現
- ✅ Inspector上で3種類のランダム化を独立して制御可能
- ✅ 実行中のBool変更が即座に反映される

---

## 📅 2026-01-16（続き5）

### Phase 17: 波の交差防止機能（完了 ✅）

#### 問題
Phase 16のランダム化実装では、各壁の速度が独立してランダム化されていたため：
- 後から発生した壁（速い）が先に発生した壁（遅い）を追い越す可能性
- 波が交差してしまう不自然な挙動

#### 解決策：速度の降順ソート
発生順序に基づいて速度を割り当て、絶対に交差しない仕様に変更

**実装方針**:
1. ランダムな速度値を生成（0.5～2.0倍）
2. 降順にソート（速い→遅い）
3. waveId順に割り当て
   - waveId=0（最初に発生）: 最速
   - waveId=1（次に発生）: 2番目に速い
   - ...
   - waveId=maxWaves-1（最後に発生）: 最遅

#### 修正箇所（RiverFlowSimulation.cs）

**1. InitializeWave()の速度初期化部分（228-280行）**:
```csharp
// 下側速度倍率（交差防止：発生順に降順ソート）
if (randomizeBottomSpeed)
{
    float[] randomBottomSpeeds = new float[maxWaves];
    for (int i = 0; i < maxWaves; i++)
    {
        randomBottomSpeeds[i] = 0.5f + (float)rng.NextDouble() * 1.5f;
    }
    // 降順にソート（速い→遅い）
    System.Array.Sort(randomBottomSpeeds);
    System.Array.Reverse(randomBottomSpeeds);
    // waveId順に割り当て（waveId=0が最速、後発ほど遅い）
    for (int waveId = 0; waveId < maxWaves; waveId++)
    {
        waveBottomSpeedMultipliers[waveId] = randomBottomSpeeds[waveId];
    }
}
```

**2. ReinitializeRandomMultipliers()（164-208行）**:
- 同様の降順ソート処理を追加
- ランタイムトグル時も交差防止が維持される

#### 効果
- ✅ 先に発生した壁が常に前方を維持
- ✅ 後から発生した壁は前の壁を追い越さない
- ✅ 波の交差が完全に防止される
- ✅ ランダム性を保ちながら自然な波の挙動を実現

#### 仕様
- **発生順序**: currentWaveIdが0→1→2→...→maxWaves-1とループ
- **画面上の位置**: waveId=0が最も右（先頭）、waveId=maxWaves-1が最も左（後方）
- **速度**: waveId=0が最速、waveId=maxWaves-1が最遅
- **結果**: 後方の壁が前方の壁を追い越すことは絶対にない

---

## 📅 2026-01-16（続き6）

### Phase 17修正: 動的速度制御による完全交差防止（完了 ✅）

#### Phase 17の問題
降順ソート方式では以下の問題が発生：
1. **waveIdループ問題**: waveId=0が再発生時に再び最速になり、後方の壁を追い越す
2. **全体的な速度上昇**: 上下両方を最速値でソートしたため、全体が速くなりすぎた

#### 解決策：動的速度制御
**実装方針**:
1. **ランダム化範囲の縮小**: 0.5～2.0倍 → 0.9～1.1倍（範囲0.2）
2. **動的速度決定**: 壁の発生時に画面上の全壁の速度を調べ、最も遅い速度より必ず遅くする

#### 実装内容（RiverFlowSimulation.cs）

**1. InitializeWave()の修正（264-276行）**:
- 降順ソート処理を削除
- 初期値1.0倍に統一（実際の速度はSpawnWaveで動的決定）

**2. ReinitializeRandomMultipliers()の修正（164-169行）**:
- 同様に降順ソート処理を削除
- 速度倍率をリセット

**3. SpawnWave()に動的速度決定ロジック追加（291-340行）**:
```csharp
// 画面上にある全ての壁の速度を調べ、最も遅い速度を見つける
float minTopSpeed = 1.1f; // 初期値（ランダム範囲の最大値）
float minBottomSpeed = 1.1f;

for (パーティクル in 画面上のパーティクル)
{
    if (topSpeed < minTopSpeed) minTopSpeed = topSpeed;
    if (bottomSpeed < minBottomSpeed) minBottomSpeed = bottomSpeed;
}

// 新しい壁の速度を決定（画面上の最も遅い速度-0.02より遅く）
float randomTop = 0.9 + Random() * 0.2; // 0.9～1.1
newTopSpeed = Max(0.8, Min(minTopSpeed - 0.02, randomTop));

float randomBottom = 0.9 + Random() * 0.2; // 0.9～1.1
newBottomSpeed = Max(0.8, Min(minBottomSpeed - 0.02, randomBottom));
```

#### アルゴリズムの仕組み
1. **最初の壁**: 画面上に壁がないため、ランダム値（0.9～1.1）がそのまま採用
2. **2番目の壁**: 1番目の壁の速度を調べ、それより0.02遅い速度が上限
3. **3番目以降**: 画面上の全壁の中で最も遅い速度より0.02遅い速度が上限
4. **下限**: 0.8倍を下回らないようにクランプ

#### 効果
- ✅ **完全交差防止**: 新しい壁は画面上の全ての壁より必ず遅い
- ✅ **waveIdループ対応**: waveIdに依存せず、実際の画面上の状態で判断
- ✅ **適度なランダム性**: 0.9～1.1の範囲内で自然なバリエーション
- ✅ **速度の安定化**: 全体的な速度が適切な範囲に収まる

#### 仕様
- **ランダム範囲**: 0.9～1.1倍（±10%）
- **減速ステップ**: 前の壁より0.02倍遅い
- **下限**: 0.8倍（これ以上遅くならない）
- **判定範囲**: X座標-0.1～1.2（画面上の壁のみ）

---

## 📅 2026-01-16（続き7）

### Phase 18: 横幅ランダム化上限値のInspector制御（完了 ✅）

#### 目的
横幅のランダム化範囲を固定値（0.5～2.0倍）から、Inspector上で上限値を調整可能にする

#### 実装内容（RiverFlowSimulation.cs）

**1. 新しいパラメータ追加（58-60行）**:
```csharp
[Tooltip("波の幅ランダム化の最大倍率")]
[Min(0.5f)]
public float waveWidthMaxMultiplier = 2.0f;
```

**2. ランダム化ロジック修正**:
- **変更前**: `0.5f + Random() * 1.5f` （固定で0.5～2.0倍）
- **変更後**: `0.5f + Random() * (waveWidthMaxMultiplier - 0.5f)` （0.5～設定値倍）
- 適用箇所:
  - ReinitializeRandomMultipliers()（164行）
  - InitializeWave()（225行）

#### 仕様
- **下限**: 0.5倍（固定）
- **上限**: waveWidthMaxMultiplier（Inspector上で変更可能、最小値0.5）
- **デフォルト値**: 2.0倍（従来と同じ）
- **密度**: 横幅が大きくなると密度は低下（パーティクル数は固定のため）

#### 使用例
- `waveWidthMaxMultiplier = 1.0` → 0.5～1.0倍でランダム化
- `waveWidthMaxMultiplier = 2.0` → 0.5～2.0倍でランダム化（デフォルト）
- `waveWidthMaxMultiplier = 3.0` → 0.5～3.0倍でランダム化

#### 効果
- ✅ プロジェクトの要求に応じて横幅のバリエーション範囲を柔軟に調整可能
- ✅ Inspector上でリアルタイムに変更・確認可能（OnValidate対応）
- ✅ 下限0.5倍は固定のため、極端に細い壁は発生しない

---

## 📅 2026-01-21

### Phase 19: ビルド用UI制御関数の実装（完了 ✅）

#### 目的
ビルド後のランタイムUIからパラメータを制御できるように、UnityEvent用のpublic関数を実装

#### 実装内容

**1. RiverFlowSimulation: UI制御関数（8個）**

| # | 関数名 | 型 | 用途 |
|---|--------|----|----|
| 1 | SetWaveMode(bool) | Toggle | WaveMode ON/OFF切り替え |
| 2 | SetRandomizeWaveWidth(bool) | Toggle | 波の幅ランダム化 |
| 3 | SetSpeedMultiplier(float) | Slider | 速度倍率（NormalMode） |
| 4 | SetWaveInterval(float) | Slider | 壁の生成間隔 |
| 5 | SetWaveSpeed(float) | Slider | 壁の移動速度 |
| 6 | SetWaveUndulationStrength(float) | Slider | 波の揺れ強度 |
| 7 | SetWaveWidthMaxMultiplier(float) | Slider | 波の幅最大倍率 |
| 8 | ~~SetRandomizeTopSpeed~~ | ~~Toggle~~ | 削除 |
| 9 | ~~SetRandomizeBottomSpeed~~ | ~~Toggle~~ | 削除 |

**2. RiverFlowVisualizer: RGB色制御関数（3個）**

| # | 関数名 | 型 | 用途 |
|---|--------|----|----|
| 1 | SetParticleColorR(float) | Slider | 赤成分（0～1） |
| 2 | SetParticleColorG(float) | Slider | 緑成分（0～1） |
| 3 | SetParticleColorB(float) | Slider | 青成分（0～1） |

**3. 速度ランダム化機能の削除**

以下を完全削除：
- `randomizeTopSpeed` / `randomizeBottomSpeed` (public bool)
- `waveSpeedMultipliers[]` / `waveBottomSpeedMultipliers[]` (private配列)
- 交差防止ロジック（SpawnWave内の速度比較・決定処理）
- Y座標による速度補間処理（UpdateParticlesWave内）
- 関連するOnValidate処理
- 関連するUI制御関数（2個）

**理由**:
- 交差防止ロジックで速度が0.8倍に収束する問題
- 上下が同じ速度になり、ランダム性が失われる問題
- 実装の複雑さに対して効果が不明瞭

**4. コードのクリーンアップ**
- 不要な変数・配列の削除
- UpdateParticlesWave()の簡略化（一律waveSpeedで移動）
- ReinitializeRandomMultipliers()の簡略化（幅倍率のみ）

#### UnityEventでの接続方法

**Toggle（OnValueChanged - Dynamic bool）**:
```
Toggle → OnValueChanged(Boolean)
  └─ Dynamic bool → SetWaveMode / SetRandomizeWaveWidth
```

**Slider（OnValueChanged - Dynamic float）**:
```
Slider → OnValueChanged(Single)
  └─ Dynamic float → SetSpeedMultiplier / SetWaveInterval / etc.
```

**RGB Slider**:
```
Red Slider   (0～1, 初期値1) → SetParticleColorR
Green Slider (0～1, 初期値1) → SetParticleColorG
Blue Slider  (0～1, 初期値1) → SetParticleColorB
```

#### 効果
- ✅ ビルド後のランタイムで全パラメータを調整可能
- ✅ Toggle/Sliderで直感的に操作
- ✅ 即座に反映（リアルタイム調整）
- ✅ コードがシンプルで保守しやすい
- ✅ RGB色制御でパーティクルの色を自由に変更可能

#### 削除による効果
- ✅ コードが大幅に簡略化
- ✅ 動作しない機能を削除し、保守性向上
- ✅ 不要な配列・変数の削除でメモリ削減

---

## 📅 2026-01-23

### Phase 20: UI実装の修正と完成（完了 ✅）

#### 問題：モード切り替え時のパーティクル消失
**症状**: SetWaveMode()でモードを切り替えると、パーティクルが流れなくなる

**原因**:
- モード切り替え時にパーティクルの再初期化が行われていない
- WaveMode → NormalMode: パーティクルが非表示位置（x: -10）のまま
- NormalMode → WaveMode: NormalModeのパーティクル配置のまま

**解決策**: SetWaveMode()にパーティクル再初期化処理を追加
```csharp
// WaveMode切り替え時
particles.Clear();
InitializeWave();
StartWaving();

// NormalMode切り替え時
CancelInvoke(nameof(SpawnWave));
particles.Clear();
InitializeNormal();
```

---

#### 問題：速度Sliderの設計
**症状**:
- NormalMode用の速度倍率Sliderを変更すると、WaveModeの揺れ具合も変わる
- WaveModeでspeedMultiplierが使用され、速度を遅くすると壁が崩れる

**原因**:
- UpdateParticlesWave()内でspeedMultiplierを使用
- 速度SliderがNormalMode専用なのに、WaveModeでも適用されていた

**解決策**: 速度Sliderを両モード対応に変更

**1. SetSpeedMultiplier()をモード判定に変更**:
```csharp
public void SetSpeedMultiplier(float speed)
{
    if (mode == SimulationMode.NormalMode)
    {
        speedMultiplier = speed;
    }
    else if (mode == SimulationMode.WaveMode)
    {
        waveSpeed = speed;
    }
}
```

**2. UpdateParticlesWave()からspeedMultiplier削除**:
```csharp
// 変更前
p.position.x += waveSpeed * Time.deltaTime + velocity.x * dt * speedMultiplier * waveUndulationStrength;
p.position.y += velocity.y * dt * speedMultiplier * waveUndulationStrength;

// 変更後
p.position.x += waveSpeed * Time.deltaTime + velocity.x * dt * waveUndulationStrength;
p.position.y += velocity.y * dt * waveUndulationStrength;
```

**3. SetWaveSpeed()削除**:
- SetSpeedMultiplier()に統合されたため不要

---

#### UI実装完成

**全UI制御関数（10個）**:

| # | 関数名 | 型 | 用途 | 備考 |
|---|--------|----|----|------|
| 1 | SetWaveMode(bool) | Toggle | WaveMode ON/OFF | パーティクル再初期化対応 |
| 2 | SetRandomizeWaveWidth(bool) | Toggle | 波の幅ランダム化 | - |
| 3 | SetSpeedMultiplier(float) | Slider | 速度 | 両モード対応 |
| 4 | SetWaveInterval(float) | Slider | 壁の生成間隔 | WaveMode専用 |
| 5 | SetWaveUndulationStrength(float) | Slider | 波の揺れ強度 | WaveMode専用、0=壁、1=波 |
| 6 | SetWaveWidthMaxMultiplier(float) | Slider | 波の幅最大倍率 | WaveMode専用 |
| 7 | SetParticleColorR(float) | Slider | 赤成分 | 0～1 |
| 8 | SetParticleColorG(float) | Slider | 緑成分 | 0～1 |
| 9 | SetParticleColorB(float) | Slider | 青成分 | 0～1 |
| 10 | ~~SetWaveSpeed~~ | - | - | 削除（SetSpeedMultiplier統合） |

---

#### コードクリーンアップ

**VectorFieldTest.cs**:
- Start()内のデバッグログ2行削除
- 不要な初期テスト出力を削除

---

#### 効果

- ✅ モード切り替えが正常に動作（パーティクル消失を解決）
- ✅ 速度Sliderが両モード対応（NormalMode: speedMultiplier、WaveMode: waveSpeed）
- ✅ WaveModeで速度と揺れ強度を独立制御可能
- ✅ 全UI実装完了（Toggle 2個、Slider 8個）
- ✅ ビルド後のランタイムで全パラメータを調整可能

---

## 📅 2026-01-23（続き）

### Phase 21（続き）: Pythonスクリプト特定

#### 調査結果

**カメラアクセス + 速度計測Pythonスクリプトを特定**:

`D:\imamura\work\SurfaceVelocimetry\notebooks`内の全ノートブックを調査した結果、以下を確認：

**最新ファイル**:
- **ファイル名**: `AdaptiveSTIV.ipynb`
- **フルパス**: `D:\imamura\work\SurfaceVelocimetry\notebooks\AdaptiveSTIV.ipynb`
- **最終更新**: 2026年1月19日 13:26
- **方式**: YOLO + STIV法（Space-Time Image Velocimetry）
- **カメラID**: 1
- **出力単位**: m/s（物理単位）
- **特徴**: YOLOによる物体検出でスケール（m/px）を自動補正

**他の候補**:
- `SurfaceVelocimetry.ipynb` (2026-01-18 16:00) - YOLO + ByteTrack、px/s出力、CSV保存機能あり
- `STIV.ipynb` (2026-01-19 13:03) - STIV法のみ、カメラID 0
- `tracking_speed.ipynb` (2026-01-18 12:08) - ホモグラフィ変換必須（実行不可）

**次のステップ**: AdaptiveSTIV.ipynbをUnity連携用.pyファイルに変換

#### .ipynb → .py 変換完了

**元ファイル**: `D:\imamura\work\SurfaceVelocimetry\notebooks\AdaptiveSTIV.ipynb` （読み取り専用、毀損なし）

**変換後ファイル**:
- **ファイル名**: `river_speed_camera.py`
- **フルパス**: `D:\seimiya\Unity\RiverProjectionMap_ver26110\Assets\StreamingAssets\PythonScripts\river_speed_camera.py`
- **配置理由**: StreamingAssetsはビルド後も含まれるため

**変換内容**:
- ✅ コードセルのみを抽出
- ✅ matplotlib関連削除（plt.figure, plt.show等）
- ✅ %matplotlib inline削除
- ✅ テスト実行部分削除
- ✅ 無限ループ化（継続的に速度計測）
- ✅ 標準出力にprint()で速度値を出力（Unity連携用）
- ✅ エラーハンドリング追加
- ✅ "READY"メッセージでUnity側に準備完了を通知

**出力形式**:
```
READY
1.2345
1.3456
1.2789
...
```

**次のステップ**: CameraSpeedReceiver.csの`scriptPath`を設定して動作テスト

---

## 📅 2026-01-25

### Phase 21（完了）: Python-Unity統合・外部カメラアクセス実装

#### 目的
外部USBカメラ（eMeet C960）で川の速度を計測し、RiverFlowSimulationの速度に反映

#### 実装内容

**1. baseline_stiv.pyをUnityプロジェクトにコピー**:
- コピー元: `D:\imamura\work\SurfaceVelocimetry\src\baseline_stiv.py`
- コピー先: `Assets/StreamingAssets/PythonScripts/baseline_stiv.py`
- カメラ情報出力機能追加（ID、解像度、FPS、Backend）

**2. CameraSpeedReceiver.cs実装**:
- カメラID設定機能（0-1: 内蔵カメラ、2以降: カメラ名必須）
- Python subprocess実行・速度値受信
- 自動速度反映機能（RiverFlowSimulation.SetSpeedMultiplier）
- 計測失敗判定（minimumValidSpeed閾値）

**3. 外部カメラアクセス問題の解決**:

**問題**:
- eMeet C960がOpenCV列挙（ID 0-1）に含まれない
- DirectShowでカメラ名指定が失敗
  - エラー: `VIDEOIO(DSHOW): backend is generally available but can't be used to capture by name`

**解決策: カメラ名→ID変換関数**:
- `find_camera_id_by_name()` 追加（baseline_stiv.py:38-71）
- WMIでWindowsのカメラリストを取得
- カメラ名が一致するデバイスのOpenCV IDを特定
- ID指定で`cv2.VideoCapture()`を開く

**コード**:
```python
def find_camera_id_by_name(camera_name: str) -> Optional[int]:
    try:
        import wmi
        c = wmi.WMI()
        cameras = c.Win32_PnPEntity(PNPClass="Camera")

        camera_index = 0
        for cam in cameras:
            if camera_name in cam.Name:
                for test_id in range(10):
                    cap = cv2.VideoCapture(test_id)
                    if cap.isOpened():
                        cap.release()
                        if test_id == camera_index:
                            return test_id
                camera_index += 1
        return None
    except Exception as e:
        print(f"[ERROR] Failed to find camera by name: {e}")
        return None
```

**動作結果**:
```
[INFO] Camera 'HD Webcam eMeet C960' found at ID 0
=== Camera Information ===
Camera ID: HD Webcam eMeet C960
Resolution: 640x480
FPS: 30.0
Backend: MSMF
=========================
Estimated Surface Velocity: -0.007968 [m/s]
```

✅ **eMeet C960アクセス成功**

#### 既存機能への影響
- ✅ ID 0, 1（数値指定）: 既存動作そのまま（影響なし）
- ✅ カメラ名（文字列指定）: WMI検索 → ID変換（新機能）

#### 残課題
- [ ] 速度閾値判定の改善（絶対値判定 or 閾値調整）
- [ ] NumPyダウングレード（`numpy<2`）

---

## ⚠️ 教訓追加（2026-01-25）

### 10. 安易に諦めない・簡単な解決策を見落とさない

**問題**: DirectShowでカメラ名アクセスできない → 「使用できません」と諦めた

**根本原因**:
- 1つの方法が失敗しただけで諦めた
- カメラ名→ID変換という基本的な発想ができなかった
- ユーザーの「OpenCVに登録したらええやん」で気づいた

**正しい対応**:
1. **[MANDATORY]** 1つの方法が失敗しても、別の角度から考える
2. **[MANDATORY]** 「できません」と諦める前に、複数の解決策を検討する
3. **[MANDATORY]** 簡単な解決策（カメラ名→ID変換）を見落とさない

**違反の結果**:
**安易な諦めは、ユーザーの信頼を完全に失う。簡単でしょうもないことを諦めてはならない。**

---

#### 流れ方向規約（STIV）

**質問**: カメラから見て左から右に流れてるのを正として見てるのか？

**回答**: はい、その通りです。

**STIVアルゴリズムの流れ方向規約**:
- baseline_stiv.pyのデフォルトライン座標: `--line-start 100 240 --line-end 540 240`
- 画像座標系でX=100 → X=540（左から右）
- **正の速度**: line_start → line_end 方向 = **左から右の流れ**
- **負の速度**: line_end → line_start 方向 = **右から左の流れ**

**テスト結果の解釈**:
- -0.012404 m/s, -0.002767 m/s（負） = 右から左への動き
- 0.015303 m/s（正） = 左から右への動き

---

## 📅 2026-01-25（続き）

### Phase 22: UI実装（カメラ計測・Bloom制御）（完了 ✅）

#### 目的
ビルド後のランタイムUIでカメラ計測とBloom Intensityを制御可能にする

#### 実装内容

**1. STIV検出パラメータのモード別設定**:
- テストモードOFF時：基準値を使用（sigmaPre: 1.0, sigmaTensor: 2.0, maxFrames: 300）
- テストモードON時：Inspector設定値を使用

**2. 即時計測ボタン実装**（CameraSpeedReceiver.cs）:
- public Button measureButton 追加
- UpdateButtonState() 実装
- Update()でisProcessing変更監視
- 計測中（isProcessing = true）：ボタン無効化（グレーアウト）
- 計測完了（isProcessing = false）：ボタン有効化

**UI設定方法**:
- Button → OnClick() → CameraSpeedReceiver → StartMeasurementNow()
- InspectorでMeasure Buttonフィールドに設定

**3. 計測間隔設定スライダー**:
- 関数名：SetMeasurementInterval(float)
- 範囲：15～300秒
- 基準値：15秒

**4. カメラ名修正**:
- 誤：HFD Camera → 正：FHD Camera
- WMIで確認したカメラ一覧：FHD Camera, ASUS IR camera, ASUS FHD webcam

**5. GlobalVolumeController.cs新規作成**:
- BloomのIntensity制御クラス
- public Volume globalVolume（Inspector設定）
- SetIntensity(float)関数（UI Slider用）
- bloom.intensity.overrideState = true で即座に反映

**UI設定方法**:
- Slider → OnValueChanged(Single) → Dynamic float → SetIntensity
- InspectorでGlobal Volumeフィールドに対象Volume設定

#### 効果
- ✅ ビルド後のランタイムで即時計測・間隔設定が可能
- ✅ 計測中のボタン連打防止
- ✅ Bloom Intensityをスライダーで調整可能（粒子の光の強度制御）
- ✅ テストモードと本番モードで適切なパラメータ自動切り替え

---

**最終更新**: 2026-01-25
