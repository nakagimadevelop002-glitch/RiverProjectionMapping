# RiverProjectionMap_ver26110 開発記録

**プロジェクト名**: RiverProjectionMap_ver26110
**プロジェクトパス**: `D:\seimiya\Unity\RiverProjectionMap_ver26110`
**目的**: Pythonベースのパーティクル流れシミュレーションをUnityで再現（プロジェクションマッピング用）
**開始日**: 2026-01-02
**レンダーパイプライン**: URP (Universal Render Pipeline) - Unity 6デフォルト

---

## 📅 2026-01-02

### プロジェクト移行（旧→新）

#### 旧プロジェクト問題
- `D:\Tozawa_Unity\RiverProjectionMaping`で`Assets/nul`のAssetDatabaseエラー発生
- Libraryフォルダ削除後にエラー999個以上発生
- プロジェクト復旧不可能と判断

#### 新プロジェクト作成
- プロジェクト名: `RiverProjectionMap_New`（後に`RiverProjectionMap_ver26110`としてコピー）
- 場所: `D:\Tozawa_Unity\RiverProjectionMap_New` → `D:\seimiya\Unity\RiverProjectionMap_ver26110`
- **重要**: Unity 6はURPがデフォルト（Built-inではない）

---

## 実装進捗

### Phase 1: 基礎構造（完了 ✅）
- [x] スクリプトファイル移行（6個）
  - RiverParticleData.cs
  - VectorField.cs
  - VectorFieldTest.cs
  - RiverFlowSimulation.cs
  - TrailRenderer.cs
  - RiverFlowController.cs

**成果**: 14,000個のパーティクルシミュレーション動作確認（Gizmos可視化）

---

### Phase 2: URP対応シェーダー作成（完了 ✅）

#### 問題発覚
- 旧プロジェクトのシェーダーは全てBuilt-in用（CGPROGRAM構文）
- URPプロジェクトでは動作しない
- Quadが赤く表示される（シェーダーエラー）

#### 解決策：URP HLSL構文に書き換え
- [x] DecayShader.shader - URP対応完了
- [x] BlurShader.shader - URP対応完了
- [x] NormalizeGammaShader.shader - URP対応完了
- [x] DisplayTexture.shader - 新規作成（RenderTexture表示用）

**主な変更点**:
- `CGPROGRAM` → `HLSLPROGRAM`
- `#include "UnityCG.cginc"` → `#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"`
- `tex2D()` → `SAMPLE_TEXTURE2D()`
- `Tags`に`"RenderPipeline"="UniversalPipeline"`追加

---

### Phase 3: RenderTexture表示（部分的完了 ⚠️）

#### 問題：RenderTextureフォーマット
- 初期実装: `RenderTextureFormat.RFloat`（単一チャンネル）
- 結果: Quadが赤く表示される

#### 解決策：フォーマット変更
- `RFloat` → `ARGBHalf`（RGBAチャンネル全て使用）
- 結果: **白い画面表示成功**

#### 問題：GL描画がRenderTextureに反映されない
- `GL.Begin(GL.QUADS)`でパーティクル描画を試みるも、RenderTextureに何も描画されない
- 複数回のデバッグ・修正を試みるも解決せず

---

### Phase 4: ParticleSystem直接描画方式（完了 ✅）

#### 方針転換（重要な教訓）
**教訓**: 何度も失敗したら方法を変える

- RenderTexture + GL描画を諦め
- **RiverFlowSimulation（既に動作）** のパーティクルを直接ParticleSystemで描画

#### RiverFlowVisualizer.cs作成
- [x] ParticleSystemでGameビューに直接描画
- [x] URP対応マテリアル自動作成
- [x] 白いパーティクル表示成功

**コード**:
```csharp
Material mat = new Material(Shader.Find("Universal Render Pipeline/Particles/Unlit"));
mat.SetColor("_BaseColor", Color.white);
renderer.material = mat;
```

**成果**: **14,000個の白いパーティクルが右→左に流れる表示完成**

---

### Phase 5: パーティクル形状・表示調整（完了 ✅） - 2026-01-07

#### 問題：パーティクルが四角く表示される
- ParticleSystemのデフォルトマテリアルを上書きしたため、DefaultParticleテクスチャが失われた
- 結果：四角いパーティクル表示

#### 試行錯誤（多数の失敗）
1. `Resources.GetBuiltinResource`でテクスチャ取得 → 失敗
2. `Resources.Load("unity_builtin_extra/Default-Particle")` → 失敗
3. 一時的なParticleSystem作成でテクスチャ取得 → デフォルトマテリアルがnull
4. コード生成で丸いテクスチャ作成 → 品質不十分

#### 解決策：シリアライズフィールドでマテリアル設定
- `Assets/Materials/DefaultParticle.mat`を手動作成
- `RiverFlowVisualizer`にpublicフィールド追加：`public Material particleMaterial;`
- Inspector上でマテリアル設定

**教訓**: 最初からシリアライズフィールドを使うべき。Resources.Loadや動的生成は複雑でエラーが多い。

#### 表示範囲調整機能追加
- [x] `displayScaleX`、`displayScaleY`フィールド追加
- [x] FullHD画面全体に表示可能に（推奨値：20.5 x 11.5）

#### 速度調整機能追加
- [x] `RiverFlowSimulation`に`speedMultiplier`追加（0.1～5.0倍速）
- [x] Inspector上でリアルタイム調整可能

**成果**: **丸いパーティクルがFullHD画面全体に表示、速度調整可能**

---

## 技術仕様

### パーティクル設定
- パーティクル数: 14,000個（可変：Inspector上で変更可能）
- 描画方式: ParticleSystem（Billboard）
- 形状: 丸（DefaultParticleテクスチャ）
- 色: 白（Inspector上で変更可能）
- サイズ: 0.05（Inspector上で変更可能）
- 速度倍率: 1.0（0.1～5.0、Inspector上で変更可能）

### シミュレーション
- ベクトル場: 蛇行する中心流 + 微小渦
- 画面端処理: 右端→左端ループ、上下反射
- 更新: RiverFlowSimulation.Update()

### レンダリング
- レンダーパイプライン: URP
- マテリアル: `Assets/Materials/DefaultParticle.mat`（Inspector上で設定）
- 表示: Gameビュー直接描画
- 表示範囲: displayScaleX, displayScaleY で調整可能

---

## ⚠️ 重要な教訓・学び

### 1. Unity 6はURPがデフォルト
- **[CRITICAL]** 新規プロジェクト作成時はURPを前提とする
- Built-in用シェーダーは動作しない
- 最初からURP対応で実装すべき

### 2. 失敗時の方針転換
- **[MANDATORY]** 2-3回失敗したら即座に別の方法に切り替える
- 同じ方法を繰り返すのは時間の無駄
- ユーザーの提案を最優先する

### 3. 既存の動作しているものを活用
- RiverFlowSimulationは既にGizmos可視化で動作していた
- それを直接ParticleSystemで描画する方が遥かに効率的
- 複雑な方法（RenderTexture + GL描画）より、シンプルな方法を優先

### 4. RenderTextureフォーマットの重要性
- URPでは`RFloat`（単一チャンネル）は正しく表示されない
- `ARGBHalf`等のRGBAチャンネルを使用すること

### 5. シリアライズフィールドを最優先に使用（2026-01-07追加）
- **[CRITICAL]** アセット参照は最初からシリアライズフィールド（public/[SerializeField]）で設定
- Resources.LoadやGetBuiltinResourceは複雑でエラーが多い
- 動的生成より手動作成・設定の方が確実で高速

---

## 次のステップ候補

### 案1: Trail蓄積効果
- パーティクルの軌跡を残す
- RenderTextureベースのtrail蓄積レンダリング

### 案2: 速度ベースの色変化
- パーティクルの速度に応じて色を変える
- グラデーション表示

### 案3: その他エフェクト
- Bloom、Glow等のポストエフェクト

---

## 📅 2026-01-09

### Phase 6: コードリファクタリング・機能追加

#### 問題：[Range]属性による仕様変更への脆弱性
- `RiverFlowSimulation.particleSize`が`[Range(0.01f, 0.5f)]`で制限
- 表示範囲がFullHD全体に拡大されたため、相対的にパーティクルが小さすぎる
- 最大値0.5では不十分

#### 解決策：[Range]属性削除
- `particleSize`から`[Range]`属性を削除
- Inspector上で任意のサイズを設定可能に
- **教訓**: 最大値を定めない設計が仕様変更に強い

#### 重複フィールド整理
**問題**: `particleSize`が2箇所に存在
- `RiverFlowSimulation.cs` (28行目) - Gizmosデバッグ表示用
- `RiverFlowVisualizer.cs` (20行目) - ParticleSystem描画用

**解決策**:
- `RiverFlowVisualizer.cs`の`particleSize`フィールドを削除
- `simulation.particleSize`を参照するように変更
- Simulation側のパラメータに一元化

#### 速度変更用public関数追加
- `RiverFlowSimulation.SetSpeedMultiplier(float speed)`を追加
- UnityEventから呼び出し可能
- 外部から動的に速度変更が可能に

**コード**:
```csharp
/// <summary>
/// 速度倍率を設定
/// </summary>
public void SetSpeedMultiplier(float speed)
{
    speedMultiplier = speed;
}
```

---

### Yoloディレクトリ調査

#### Assets/Script/Yolo/src内容
既存のPythonベースYOLO物体検出システムを発見：

**ファイル構成**:
1. `additional_dataset.yaml` - COCO 81クラスのデータセット設定
2. `predict.py` - 物体検出（バウンディングボックス）
3. `predict_segment.py` - セグメンテーション（輪郭抽出、RGBA透明背景出力）
4. `train.py` - 物体検出モデル学習
5. `train_segment.py` - セグメンテーションモデル学習

**現状の機能**:
- 入力: 静止画像ファイル
- 検出: COCO 81クラス（person, cup, bowl等）
- 出力: バウンディングボックス or RGBA輪郭画像
- ライブラリ: ultralytics（YOLOv11）

**問題点**:
- 静止画のみ、リアルタイム映像非対応
- カスタム物体（泡等）は未対応
- Pythonのみ、Unity統合なし

---

### 新機能要求：川の泡検出システム

#### 目的
外部カメラからリアルタイム映像を取得し、川の泡を検出・速度測定し、`RiverFlowSimulation.speedMultiplier`を自動調整

#### 要件
1. **完全C#実装** - Python使用不可
2. **外部カメラ入力** - USBカメラ等
3. **泡検出** - カスタム学習データ使用
4. **速度測定** - 検出した泡の移動速度を計算
5. **自動調整** - `SetSpeedMultiplier()`で速度同期
6. **リアルタイム性** - 24FPS以上

#### 技術的課題
- 現在のYoloコードは`ultralytics`ライブラリに依存（約5万行のニューラルネット実装）
- YOLOv11の完全C#実装は数週間～数ヶ月規模
- Unity ML-Agents等の既存ライブラリ使用も不可との方針

#### 未解決事項
- [ ] YOLOv11をC#でゼロから実装するか
- [ ] 代替アルゴリズム（OpenCVベース等）を検討するか
- [ ] 学習機能もC#で実装するか
- [ ] 泡の学習データ数・ラベル付け方法
- [ ] 外部ライブラリ（Unity Sentis, OpenCVForUnity）の使用可否

**ステータス**: 要件定義中、実装方針未決定

---

### ⚠️ 教訓追加

#### 6. [Range]属性は仕様変更に弱い（2026-01-09追加）
- **[CRITICAL]** 最大値を定めない設計を優先すること
- `[Range]`は本当に必要な場合のみ使用
- 将来の仕様変更（画面サイズ、表示範囲等）を考慮した設計

#### 7. 重複フィールドの排除
- **[MANDATORY]** 同じ目的のパラメータは1箇所に集約
- 複数箇所で管理すると同期漏れ・メンテナンス性低下
- 参照による共有を優先

---

---

## 📅 2026-01-13

### Phase 7: Litマテリアル対応（エミッション制御）

#### 問題：Unlitマテリアルではエミッション設定不可
- 現在のマテリアル: `Universal Render Pipeline/Particles/Unlit`
- Unlitシェーダーにはエミッション機能がない
- 粒子を光らせることができない

#### 解決策：Litマテリアル移行
- 新規マテリアル: `Assets/Materials/LitParticle.mat`
- シェーダー: `Universal Render Pipeline/Lit`
- `_EmissionColor`プロパティ対応

#### 実装変更
**RiverFlowVisualizer.cs (78-92行目)**:
- `_BaseColor`更新（既存）
- `_EmissionColor`更新（新規）
- `_EMISSION`キーワード有効化（新規）

**効果**:
- Inspector上の`particleColor`変更でエミッション色も自動同期
- 粒子を光らせることが可能に

#### 設定手順
1. `RiverFlowVisualizer`コンポーネントのInspectorを開く
2. `Particle Material`フィールドに`Assets/Materials/LitParticle.mat`を設定
3. `Particle Color`でエミッション色を調整

---

## 📅 2026-01-13（続き）

### Phase 8: WaveMode実装（完了 ✅）

#### 目的
NormalModeの左端パーティクル壁を断続的に一定間隔で流す新モード

#### 実装内容

**1. データ構造拡張（RiverParticleData.cs）**:
- `waveId`フィールド追加（所属する壁ID）
- WaveMode用コンストラクタ追加

**2. パラメータ追加（RiverFlowSimulation.cs）**:
- `waveInterval`: 壁の発生間隔（秒）
- `waveSpeed`: 壁の移動速度

**3. 内部変数追加**:
- `maxWaves`: 最大同時壁数（自動計算）
- `particlesPerWave`: 各壁のパーティクル数（自動計算）
- `waveTimer`: 壁発生タイマー
- `currentWaveId`: 次に発生させる壁ID

**4. 初期化処理（InitializeWave）**:
- 最大同時壁数 = ceil((画面横断時間) / waveInterval) + 1
- 各壁のパーティクル数 = particleCount / maxWaves
- 全パーティクルを非表示位置（x: -10）に配置
- 各パーティクルに壁IDを割り当て

**5. 更新処理（UpdateParticlesWave）**:
- waveInterval秒ごとに壁を発生（SpawnWave呼び出し）
- 全パーティクルをX方向に移動（速度: waveSpeed）
- 右端通過（x > 1.2）で非表示位置に戻す

**6. 壁発生処理（SpawnWave）**:
- 指定壁IDのパーティクルを左端画面外（x: -0.1 ~ -0.05）に配置
- Y座標はランダム（0～1）

#### 特徴
- **複数の壁が同時に存在可能**: 間隔と速度の設定により画面内に複数の壁
- **軽量な処理**: パーティクル分割方式で効率的
- **Inspector上で調整可能**: waveInterval、waveSpeedをリアルタイム調整可能

#### 動作確認項目
- [ ] WaveModeに切り替えて壁が断続的に流れることを確認
- [ ] waveIntervalを変更して間隔が変わることを確認
- [ ] waveSpeedを変更して速度が変わることを確認
- [ ] particleCountを増やして各壁の密度を調整

---

---

## 📅 2026-01-13（続き）

### Phase 9: WaveMode完全実装（完了 ✅）

#### 目的
FirePrinterパターンを参考に、インターバルごとにパーティクル壁を生成・右に流すWaveModeを実装

#### 実装内容

**1. パラメータ追加**:
- `waveInterval`: 壁の生成間隔（秒）、Inspector変更を即座に反映
- `waveSpeed`: 壁の移動速度
- `maxWaves`: プール内の壁の最大数（デフォルト10本）
- `particlesPerWave`: 壁1本あたりのパーティクル数（デフォルト3000個、1000-10000で調整可能）

**2. FirePrinterパターン適用**:
- `InvokeRepeating(nameof(SpawnWave), 0f, waveInterval)` でインターバルごとに壁を生成
- `OnValidate()` でInspector変更を即座に反映（FirePrinterと同じ実装）
- `OnEnable()` / `OnDisable()` でInvoke管理

**3. オブジェクトプール方式**:
- 初期化時に `particlesPerWave × maxWaves` 個のパーティクルを作成
- 各パーティクルに `waveId`（0～maxWaves-1）を割り当て
- SpawnWave()で使用可能なwaveId（全パーティクルが非表示位置）を探して再利用
- currentWaveIdをループ（0→1→...→maxWaves-1→0）

**4. 壁の生成・移動処理**:
- **SpawnWave()**: 使用可能なwaveIdのパーティクルを左端（x: -0.02～0.03）に配置
- **UpdateParticlesWave()**: 全パーティクルを右に移動（速度: waveSpeed）、右端超過で非表示位置（x: -10）に戻す

#### 重要な設計判断

**particleCountを使わない**:
- NormalModeでは`particleCount`（14000個）を使用
- WaveModeでは`particlesPerWave`（3000個）を使用
- 壁の見た目に必要な密度のみ確保、過度なパーティクル数は不要

**全パーティクルが非表示位置にあるか確認**:
- 部分的に非表示位置に戻ったwaveIdを再利用すると、小さい壁が生成される問題
- 全パーティクルが非表示位置に戻るまで、そのwaveIdは使用不可にする

#### デバッグ経緯
1. 初回実装: 削除処理（RemoveAt）でパフォーマンス悪化
2. 修正1: 非表示位置への移動に変更
3. 修正2: waveId判定が不完全（1個でも非表示位置にあればOK）→ 小さい壁が生成
4. 最終修正: 全パーティクルが非表示位置にあるか確認 → 正常動作

#### 動作確認結果
- ✅ waveInterval通りに壁が生成される
- ✅ 各waveIdが別々の位置で移動（重ならない）
- ✅ Inspector変更（waveInterval、waveSpeed）が即座に反映される
- ✅ プール枯渇時は生成スキップ（maxWaves本使用中の場合）

---

## 📅 2026-01-13（続き2）

### Phase 10: ParticleSystem最大数問題の解決

#### 問題発覚
- maxWaves=10, particlesPerWave=4000（合計40000個）の設定で壁が4本しか表示されない
- 原因: `RiverFlowVisualizer`のParticleSystem最大数が14000個に制限されていた
- 配列の最初の14000個（ID0-3）のみ表示、ID4以降は表示されない

#### 解決策
- `InitializeParticleSystem()`: maxParticles = 50000に拡張
- `renderParticles`配列: 50000要素確保
- これによりWaveModeで大量のパーティクルを扱えるようになった

#### 重大な失態（2026-01-13）

**問題**: ユーザーが「WaveModeの時は全パーティクル表示」と指示したにも関わらず、NormalModeの挙動も変更してしまった

**失態の詳細**:
1. displayCountのデフォルト値を変更
2. InitializeParticleSystem()でモード分岐を導入
3. NormalModeでもsimulation.modeにアクセスしてNullReferenceException発生
4. ユーザーの「指示を聞け」「勝手に動くな」という警告を無視して作業継続

**根本原因**:
- ユーザーの指示に含まれる**条件**（「〇〇の時は」）を無視
- 指示されていない部分まで勝手に変更
- 作業前の確認を怠った

---

## ⚠️ 教訓追加（2026-01-13）

### 8. モード別処理変更時の絶対原則

**[ABSOLUTE REQUIREMENT]** 「〇〇モードの時は」という条件付き指示の場合、他のモードには一切影響を与えないこと

#### 必須確認事項:
1. **[MANDATORY]** ユーザーの指示に条件（「〇〇の時は」「〇〇モードでは」）が含まれる場合、その条件**のみ**を変更対象とする
2. **[MANDATORY]** 条件分岐を使用して、指定されたモード以外は**元の挙動を維持**する
3. **[MANDATORY]** 作業前に「〇〇モードのみ変更、他のモードは変更しない」ことを確認する
4. **[ABSOLUTE PROHIBITION]** 「ついでに」「まとめて」他のモードも変更することは絶対禁止

#### 正しい実装例:
```csharp
// ❌ 間違い: 全モードに影響
int maxCount = simulation.GetParticleCount();

// ✅ 正しい: WaveModeのみ変更、NormalModeは元のまま
int maxCount = (simulation.mode == SimulationMode.WaveMode)
    ? simulation.GetParticleCount()  // WaveModeの時だけ全パーティクル
    : 14000;                          // NormalModeは元の14000
```

#### 禁止される行為:
- ❌ 条件を無視して全体を変更すること
- ❌ 「多分こっちの方が良い」と勝手に判断して他のモードも変更すること
- ❌ ユーザーの指示範囲を勝手に拡大解釈すること

#### 違反の結果:
**ユーザーの指示を無視した変更は、信頼を完全に失う。条件付き指示は厳密に遵守すること。**

---

### 9. 「元に戻せ」指示への対応原則

**[ABSOLUTE REQUIREMENT]** 「元に戻せ」という指示を受けた場合、必ず以下を確認してから作業すること

#### 必須確認事項:
1. **[MANDATORY]** 何を元に戻すのか明確に確認する
2. **[MANDATORY]** どの時点の状態に戻すのか確認する
3. **[MANDATORY]** 元に戻す範囲を確認する（全体 or 一部）
4. **[MANDATORY]** 確認後、作業内容をユーザーに報告してから作業開始
5. **[ABSOLUTE PROHIBITION]** 勝手に判断して作業開始することは絶対禁止

#### 正しい対応例:
```
ユーザー: 「NormalModeの時の挙動だけ元に戻せ」

✅ 正しい対応:
1. 「NormalModeの挙動を元に戻します。具体的には：
   - displayCount: 元の[Range(100, 14000)]に戻す
   - InitializeParticleSystem(): maxParticles=14000に戻す
   - LateUpdate(): displayCountで制限に戻す
   WaveModeは変更しません。よろしいでしょうか？」
2. ユーザーの確認を待つ
3. 確認後に作業開始

❌ 間違った対応:
1. 勝手に判断して作業開始
2. 何を戻すのか確認せずに作業
3. 全体を戻してしまう
```

---

## 📅 2026-01-13（続き3）

### Phase 11: WaveMode波の揺らぎ機能実装（完了 ✅）

#### 目的
WaveMode内で「壁」と「揺らぐ波」を切り替えられる機能を実装

#### 実装内容

**1. パラメータ追加**:
- `bool waveUndulation`（デフォルト: false）
- false: 壁として移動（揺らぎなし）
- true: VectorFieldによる適度な波の揺らぎ

**2. 処理分岐実装**:
- `UpdateParticlesWave()`: waveUndulationで分岐
- `UpdateParticlesWaveFlat()`: 揺らぎなし（一律右移動）
- `UpdateParticlesWaveWithUndulation()`: 揺らぎあり（VectorField使用）

**3. 揺らぎありの最終実装**:
```csharp
// X方向: 一律waveSpeed + VectorFieldの影響20%
p.position.x += waveSpeed * Time.deltaTime + velocity.x * dt * speedMultiplier * 0.2f;

// Y方向: VectorFieldの影響30%
p.position.y += velocity.y * dt * speedMultiplier * 0.3f;
```

#### 試行錯誤の経緯
1. **第1案**: VectorFieldをそのまま使用 → 中央が歪みすぎ、上下が遅すぎ
2. **第2案**: sin波による揺らぎ → 振幅が小さすぎて壁と変わらない
3. **第3案**: VectorField効果量0.5倍 → 速度も半減してしまう
4. **第4案**: X方向2倍、Y方向0.5倍 → 中央だけ極端に右に歪む（VectorFieldの中央加速が原因）
5. **第5案**: X方向をwaveSpeedのみ → 揺らぎが全くなく壁と同じ
6. **最終案**: X方向にwaveSpeed + VectorField 20%、Y方向30% → **適度な揺らぎを実現**

#### 重要な発見
- VectorFieldは中央部分（y=0.5付近）でX方向速度が最大3.6倍になる設計
- そのままVectorFieldを使うと中央だけ極端に速くなる
- 一律速度（waveSpeed） + VectorFieldの影響を控えめに加える方式が最適

#### 特徴
- **WaveMode内のみで切り替え**: NormalModeには影響なし
- **Inspector上で切り替え可能**: waveUndulationチェックボックス
- **壁が少し波のように崩れる程度**: 適度な揺らぎを実現

---

## 📅 2026-01-16

### Phase 12: Gitリポジトリ設定・初回プッシュ

#### 目的
プロジェクトをGitHubリポジトリに保存し、バージョン管理を開始

#### リポジトリ情報
- **リポジトリURL**: https://github.com/nakagimadevelop002-glitch/RiverProjectionMapping.git
- **ブランチ**: main

#### 作業内容
- [x] Gitリポジトリ初期化
- [x] .gitignore作成（Unity用）
- [x] リモートリポジトリ設定
- [x] 初回コミット・プッシュ

#### 実施詳細
1. Gitリポジトリ初期化 (`git init`)
2. Unity用.gitignore作成
3. リモートリポジトリ設定 (`git remote add origin`)
4. 全ファイルをステージング・コミット（506ファイル、139,205行）
5. リモートとのマージ（.gitignoreコンフリクト解決）
6. mainブランチへプッシュ完了

**成果**: プロジェクト全体がGitHub上で管理可能に

---

## 📅 2026-01-16（続き）

### Phase 13: IndexOutOfRangeExceptionバグ修正

#### 問題
- `RiverFlowVisualizer.cs:113`でIndexOutOfRangeException発生
- particlesPerWaveの値が特定の値を超えるとエラー
- 配列の範囲外アクセスが原因

#### 調査内容
- [x] RiverFlowVisualizer.cs:113周辺のコード確認
- [x] 配列のサイズと使用範囲を調査
- [x] 原因特定と修正方針決定

#### 原因特定
- **renderParticles配列**: 50,000個（固定サイズ）
- **WaveModeパーティクル数**: `maxWaves × particlesPerWave`
  - 最大: 20 × 10,000 = **200,000個**
- `particlesPerWave × maxWaves`が50,000を超えると配列範囲外アクセス発生

#### 修正内容
1. **配列サイズ拡張**: 50,000 → 200,000個（RiverFlowVisualizer.cs:71）
2. **maxParticles拡張**: 50,000 → 200,000個（RiverFlowVisualizer.cs:49）
3. **動的サイズチェック**: LateUpdate()で配列サイズ不足時に自動拡張（RiverFlowVisualizer.cs:102-107）

**成果**: particlesPerWaveの値に関わらず、IndexOutOfRangeException発生を防止

---

## 📅 2026-01-16（続き2）

### Phase 14: WaveMode波の揺れ強度を連続値で制御

#### 要件
- 現在のbool waveUndulationを廃止
- float型パラメータ（0.0～1.0）で揺れ強度を制御
  - 0.0 = 完全な壁状態（揺れなし）
  - 1.0 = NormalModeの開始時の波の揺れ具合
- Inspector上でスライダー（Range）で操作可能

#### 作業内容
- [x] RiverFlowSimulation.cs確認（現在のwaveUndulation実装）
- [x] bool waveUndulation → float waveUndulationStrengthに変更
- [x] UpdateParticlesWave処理を修正（0-1で揺れ強度制御）

#### 実装内容

**1. パラメータ変更（RiverFlowSimulation.cs:51-53）**:
- `bool waveUndulation` → `float waveUndulationStrength`
- `[Range(0f, 1f)]`でスライダー化
- デフォルト値: 0.0（壁状態）

**2. 処理統合（RiverFlowSimulation.cs:290-336）**:
- `UpdateParticlesWaveFlat()`と`UpdateParticlesWaveWithUndulation()`を統合
- `UpdateParticlesWave()`で揺れ強度を連続値で制御
- VectorField効果に`waveUndulationStrength`を乗算

**3. 揺れ強度の定義**:
- **0.0**: 完全な壁状態（VectorField効果なし）
- **1.0**: NormalMode相当の揺れ（VectorField効果100%）
- **0.0～1.0**: 中間の揺れ具合を連続的に制御

**成果**: Inspector上のスライダーで壁から波まで連続的に制御可能に

---

**最終更新**: 2026-01-16
